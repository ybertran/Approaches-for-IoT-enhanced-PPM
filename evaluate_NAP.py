from __future__ import print_function, division
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
from tensorflow.keras.models import load_model
import keras as keras
import numpy as np
import csv
import time
from datetime import datetime
from math import log
import pandas as pd 

pd.set_option('display.max_rows', None)

from datetime import datetime
import time

print_results = False
iot = True
context = True

#model = load_model(r"output_files\models\model_14-0.22_(29859, 634, 81)_iot_context_full_status.keras")
#model = load_model(r"output_files\models\model_43-0.31_(28449, 391, 21).keras")
#model = load_model(r"output_files\models\model_24-0.36_(12340, 797, 36)context.keras") # load model, set this to the model generated by train.py
model = load_model(r"output_files\models\model_54-0.56_(3555, 44, 20).keras") # load model, set this to the model generated by train.py

filename = 'contextualised_full_context_process_event_data_iot_context_full' # /!\ with context models, this file might be wrong because it was overwritten each time a model was trained with some activities filtered
df = pd.read_csv('data/' + filename + '_reworked.csv')
print('the shape of the data', df.shape)

# these are just the variables we need to initialize
# Create lists dynamically for each group of columns
if iot:

    IoT_seqs = {col: [] for col in df.columns if col not in ['CaseID', 'ActivityID', 'CompleteTimestamp']} # the IoT_seqs is a dictionary of column values(keys) and the values are the cases. Each case is a trace of length between 0 and 44
    IoT_lines = {col: [] for col in df.columns if col not in ['CaseID', 'ActivityID', 'CompleteTimestamp']}

lineseq, timeseqs, timeseqs2, timeseqs3, timeseqs4 = [], [], [], [], []
lastcase, line, firstLine = '', '', True
lines, times, times2, numlines, index = [], [], [], 0, 0
casestarttime, lasteventtime = None, None
step, sentences, softness, next_chars = 1, [], 0, [] # Vectorization
sentences_t, sentences_t2, sentences_t3, sentences_t4 = [], [], [], []
next_chars_t, next_chars_t2, next_chars_t3, next_chars_t4 = [], [], [], []
caseids = []

#########################################################################################
#the next code snippet basically creates lists of lists with all the relevant information
#########################################################################################

eventlog = filename + '_reworked'
csvfile = open('data/%s' % eventlog+'.csv', 'r')
datareader = csv.reader(csvfile, delimiter=',', quotechar='|') # Load data from CSV file
next(datareader, None)  # skip the headers
for row in datareader: #the columns are "CaseID, ActivityID, CompleteTimestamp"
    t = time.strptime(row[2], "%Y-%m-%d %H:%M:%S") # creates a datetime object from row[2]
    if row[0] != lastcase:  #'lastcase' is to save the last executed case for the loop. We only go in this if-statement if we have a new case
        casestarttime = t 
        lasteventtime = t
        lastcase = row[0]
        if not firstLine: # we always do this if-statement, only not for the first ever line (would add an empty list to a list)
            lineseq.append(lines)
            timeseqs.append(times)
            timeseqs2.append(times2)
            timeseqs3.append(times3)
            timeseqs4.append(times4)
            if iot:
                for index, (col, values) in enumerate(IoT_seqs.items()):
                    IoT_seqs[col].append(IoT_lines[col])
        if iot:
            IoT_lines = {col: [] for col in df.columns if col not in ['CaseID', 'ActivityID', 'CompleteTimestamp']}
        lines = []
        times = []
        times2 = []
        times3 = []
        times4 = []
        
        numlines+=1
    timesincelastevent = datetime.fromtimestamp(time.mktime(t))-datetime.fromtimestamp(time.mktime(lasteventtime))
    timesincecasestart = datetime.fromtimestamp(time.mktime(t))-datetime.fromtimestamp(time.mktime(casestarttime))
    midnight = datetime.fromtimestamp(time.mktime(t)).replace(hour=0, minute=0, second=0, microsecond=0)
    timesincemidnight = datetime.fromtimestamp(time.mktime(t))-midnight
    timediff = 86400 * timesincelastevent.days + timesincelastevent.seconds     #multiply with 60*60*24 = 86400 to go from days to seconds
    timediff2 = 86400 * timesincecasestart.days + timesincecasestart.seconds    #the .seconds method gives the time in seconds
    timediff3 = timesincemidnight.seconds #this leaves only time event occured after midnight
    timediff4 = datetime.fromtimestamp(time.mktime(t)).weekday() #day of the week
    caseids.append(row[0])
    lines.append(str(row[1])) #add the activity label to the line list
    times.append(timediff)
    times2.append(timediff2)
    times3.append(datetime.fromtimestamp(time.mktime(t)))
    times4.append(timediff4)
    if iot:
        for index, (col, values) in enumerate(IoT_lines.items()):
            IoT_lines[col].append(str(row[3 + index]))
    lasteventtime = t
    index = index+1
    firstLine = False #after the first line we set the FirstLine to False; this is because we want to save the lines and times lists to the lineseq and timeseq list for each seperate case

# add last case
lineseq.append(lines)
timeseqs.append(times)
timeseqs2.append(times2)
timeseqs3.append(times3)
timeseqs4.append(times4)
if iot:
    for index, (col, values) in enumerate(IoT_seqs.items()):
        IoT_seqs[col].append(IoT_lines[col])
numlines+=1

# Calculate divisors
divisor = np.mean([item for sublist in timeseqs for item in sublist]) # the average time difference between the event in a case and the previous event, across all events in the dataset
divisor2 = np.mean([item for sublist in timeseqs2 for item in sublist]) # average time difference since the start of a case across all events in the dataset.

print('divisor: {}'.format(divisor))
print('divisor2: {}'.format(divisor2))

maxlen = max(map(lambda x: len(x),lineseq))
chars = map(lambda x : set(x),lineseq)
chars = list(set().union(*chars))

target_chars = [0,1]

# Custom sorting function to convert strings to integers for numerical sorting
def custom_sort(item):
    return int(item)

# Sorting the list using the custom sorting function (because we sort strings based on their integer value)
chars = sorted(chars, key=custom_sort)

print('total chars: {}, target chars: {}'.format(len(chars), len(target_chars)))
print('maxlen', maxlen)
print('len lineseq', len(lineseq))
count = 0

for prefix_size in range(2,maxlen):
    print('prefix size', prefix_size)
    for counter, line in enumerate(lineseq):
        for activity in line:
            if activity =='12':
                count +=1
               
char_indices = dict((c, i) for i, c in enumerate(chars))
indices_char = dict((i, c) for i, c in enumerate(chars))
target_char_indices = dict((c, i) for i, c in enumerate(target_chars))
target_indices_char = dict((i, c) for i, c in enumerate(target_chars))

predict_size = 1 # set parameters

def getSymbol(predictions):
    maxPrediction = 0
    symbol = ''
    i = 0
    for prediction in predictions:
        if(prediction>=maxPrediction):
            maxPrediction = prediction
            symbol = target_indices_char[i]
        i += 1
    return symbol

def encode(sentence, times, times3, counter, maxlen=maxlen):
    num_features = (len(chars)+ 5)
    if iot:
        try:
            num_features+= len(IoT_seqs.keys())
        except AttributeError:
            print("IoT sequence empty: ", IoT_seqs)
    X = np.zeros((1, maxlen, num_features), dtype=np.float32)
    leftpad = maxlen-len(sentence)
    times2 = np.cumsum(times)
    for t, char in enumerate(sentence):
        midnight = times3[t].replace(hour=0, minute=0, second=0, microsecond=0)
        timesincemidnight = times3[t]-midnight
        for c in chars:
            if c==char:
                X[0, t+leftpad, char_indices[c]] = 1
        X[0, t+leftpad, len(chars)] = t+1
        X[0, t+leftpad, len(chars)+1] = times[t]/divisor
        X[0, t+leftpad, len(chars)+2] = times2[t]/divisor2
        X[0, t+leftpad, len(chars)+3] = timesincemidnight.seconds/86400
        X[0, t+leftpad, len(chars)+4] = times3[t].weekday()/7

        # Add information for IoT columns
        if iot:
            for col in IoT_seqs.keys():
                X[0, t + leftpad, len(chars) + 5 + list(IoT_seqs.keys()).index(col)] = IoT_seqs[col][counter][t]

    return X

def encode_iot(sentence, times, times3, counter, IoT_seqs, maxlen=maxlen):
    """
    Encodes a given sentence and associated time features into a 3D numpy array suitable for input into a neural network.
    Parameters:
    sentence (str): The input sentence to be encoded.
    times (list of float): List of time intervals corresponding to each character in the sentence.
    times3 (list of datetime): List of datetime objects corresponding to each character in the sentence.
    counter (int): Counter to index into IoT sequences.
    IoT_seqs (dict): Dictionary containing IoT sequences with keys as column names and values as lists of sequences.
    maxlen (int, optional): Maximum length of the encoded sequence. Defaults to the global variable `maxlen`.
    Returns:
    numpy.ndarray: A 3D numpy array of shape (1, maxlen, num_features) containing the encoded sentence and time features.
    """
    num_features = (len(chars)+ 5)
    if iot:
        try:
            num_features+= len(IoT_seqs.keys())
        except AttributeError:
            print("IoT sequence empty: ", IoT_seqs)
    X = np.zeros((1, maxlen, num_features), dtype=np.float32)
    leftpad = maxlen-len(sentence)
    times2 = np.cumsum(times)
    for t, char in enumerate(sentence):
        midnight = times3[t].replace(hour=0, minute=0, second=0, microsecond=0)
        timesincemidnight = times3[t]-midnight
        for c in chars:
            if c==char:
                X[0, t+leftpad, char_indices[c]] = 1
        X[0, t+leftpad, len(chars)] = t+1
        X[0, t+leftpad, len(chars)+1] = times[t]/divisor
        X[0, t+leftpad, len(chars)+2] = times2[t]/divisor2
        X[0, t+leftpad, len(chars)+3] = timesincemidnight.seconds/86400
        X[0, t+leftpad, len(chars)+4] = times3[t].weekday()/7

        # Add information for IoT columns
        if iot:
            for col in IoT_seqs.keys():
                X[0, t + leftpad, len(chars) + 5 + list(IoT_seqs.keys()).index(col)] = IoT_seqs[col][counter][t]

    return X


# make predictions
predictions = []
labels = []

correct = 0
counter_total = 0
correct_precision = 0
counter_total_precision = 0

with open('output_files/results/next_activity_and_time_%s' % eventlog, 'w') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(["CaseID", "Prefix length", "Ground truth", "Predicted", "MAE"])
    for prefix_size in range(2,maxlen):
        print('prefix size', prefix_size)
        for counter, (line, caseid, times, times3) in enumerate(zip(lineseq, caseids, timeseqs, timeseqs3)):
            if print_results:
                print('original trace', line)
            times.append(0)
            cropped_line = line[:prefix_size]
            cropped_times = times[:prefix_size]
            cropped_times3 = times3[:prefix_size]

            if print_results:
                print('cropped line', cropped_line)

            ground_truth = line[prefix_size:prefix_size+1]

            if print_results:
                print('ground_truth', ground_truth)

            for i in range(predict_size):
                if len(ground_truth)<=i:
                    continue
                if int(ground_truth[0]) == 12:
                    label = 1
                else:
                    label = 0
                if iot:
                    enc = encode_iot(cropped_line, cropped_times, cropped_times3, counter, IoT_seqs)
                else:
                    enc = encode(cropped_line, cropped_times, cropped_times3, counter)

                if print_results:
                    print(enc.shape)

                y = model.predict(enc, verbose=0)[0][0]
                labels.append(label)

                if print_results:
                    print('prediction', y)

                binary_prediction = 1 if y > 0.5 else 0
                if print_results:
                    print('prediction 2', binary_prediction)
                predictions.append(binary_prediction)

                #prediction = np.argmax(y_char).item() 

                if print_results:
                    print('ground truth', label)
                
                
                if label ==1:
                    counter_total_precision +=1
                    if binary_prediction == label:
                        correct_precision +=1

                counter_total +=1
                if binary_prediction == label:
                    correct +=1
                if print_results:
                    if correct >0:
                        print('total accuracy:', correct/counter_total, 'of total pump adjustments', counter_total)
                        try:
                            print('accuracy precision:', correct_precision/counter_total_precision, 'of pump adjustments', counter_total_precision)
                        except ZeroDivisionError:
                            print('accuracy precision cannot be determined because no pump adjustment was tested yet')
                    else:
                        print('accuracy is 0', counter_total)

